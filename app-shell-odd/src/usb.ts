import * as fs from 'fs'
import * as fsPromises from 'fs/promises'
import { join } from 'path'
import { flatten } from 'lodash'
import { createLogger } from './log'
import {
  robotMassStorageDeviceAdded,
  robotMassStorageDeviceEnumerated,
  robotMassStorageDeviceRemoved,
  sendFilePaths,
} from './actions'
import {
  ROBOT_MASS_STORAGE_DEVICE_ENUMERATED,
  ROBOT_MASS_STORAGE_DEVICE_REMOVED,
} from './constants'
import type { Dispatch, Action } from './types'

const FLEX_USB_MOUNT_DIR = '/media/'
const FLEX_USB_DEVICE_DIR = '/dev/'
// filter matches sda0, sdc9, sdb
const FLEX_USB_DEVICE_FILTER = /sd[a-z]+[0-9]*$/
// filter matches sda0, sdc9, sdb, VOLUME-sdc10
const FLEX_USB_MOUNT_FILTER = /([^/]+-)?(sd[a-z]+[0-9]*)$/

const log = createLogger('mass-storage')

// These are for backoff algorithm
// apply the delay from 1 sec 64 sec
const MAX_TRIES = 6
const wait = (ms: number): Promise<void> =>
  new Promise((resolve, reject) => setTimeout(resolve, ms))
const callWithRetry = async (
  fn: () => Promise<any>,
  depth: number = 0
): Promise<any> => {
  try {
    return await fn()
  } catch (e) {
    if (depth > MAX_TRIES) {
      throw e
    }
    await wait(2 ** depth * 1000)

    // eslint-disable-next-line @typescript-eslint/return-await
    return callWithRetry(fn, depth + 1)
  }
}

// These directories are generated by OSX and contain entries for all
// the files that were deleted from a mass storage device, or search index
// data
const isWeirdDirectoryAndShouldSkip = (dirName: string): boolean =>
  ['.Trashes', '.Spotlight']
    .map(keyword => dirName.includes(keyword))
    .reduce((prev, current) => prev || current, false)

const doEnumerateMassStorage = (
  path: string,
  depth: number
): Promise<string[]> => {
  log.info(`Enumerating mass storage path ${path}`)
  return callWithRetry(() =>
    fsPromises.readdir(path).then(entries => {
      if (entries.length === 0 && depth === 0) {
        throw new Error('No entries found for top level, retrying...')
      }
      return entries
    })
  )
    .then(() => fsPromises.readdir(path, { withFileTypes: true }))
    .then(entries =>
      Promise.all(
        entries.map(entry =>
          entry.isDirectory() && !isWeirdDirectoryAndShouldSkip(entry.name)
            ? doEnumerateMassStorage(join(path, entry.name), depth + 1)
            : new Promise<string[]>(resolve => {
                resolve([join(path, entry.name)])
              })
        )
      )
    )
    .catch((error: Error) => {
      log.error(
        `Error enumerating mass storage path ${path}: ${error.name}: ${error.message}`
      )
      return []
    })
    .then(flatten)
    .then(result => result)
}

const enumerateMassStorage = (path: string): Promise<string[]> => {
  log.info(`Beginning scan of mass storage device at ${path}`)
  return doEnumerateMassStorage(path, 0).then(results => {
    log.info(`Found ${results.length} files in ${path}`)
    return results
  })
}

export function watchForMassStorage(dispatch: Dispatch): () => void {
  log.info('watching for mass storage')
  let prevDirs: string[] = []
  const handleNewlyPresent = (path: string): Promise<string> => {
    dispatch(robotMassStorageDeviceAdded(path))
    return enumerateMassStorage(path)
      .then(contents => {
        log.debug(
          `mass storage device at ${path} enumerated: ${JSON.stringify(
            contents
          )}`
        )
        log.info(`Enumerated ${path} with ${contents.length} results`)
        dispatch(robotMassStorageDeviceEnumerated(path, contents))
      })
      .then(() => path)
  }

  const rescan = (dispatch: Dispatch): Promise<unknown> =>
    fsPromises
      .readdir(FLEX_USB_MOUNT_DIR)
      .then(entries => {
        const sortedEntries = entries.sort()
        const newlyPresent = sortedEntries.filter(
          entry => !prevDirs.includes(entry)
        )
        const newlyAbsent = prevDirs.filter(
          entry => !sortedEntries.includes(entry)
        )
        log.info(
          `rescan: newly present: ${newlyPresent} newly absent: ${newlyAbsent}`
        )
        return Promise.all([
          ...newlyAbsent.map(entry => {
            if (entry.match(FLEX_USB_MOUNT_FILTER)) {
              dispatch(
                robotMassStorageDeviceRemoved(join(FLEX_USB_MOUNT_DIR, entry))
              )
            }
            return null
          }),
          ...newlyPresent.map(entry => {
            if (entry.match(FLEX_USB_MOUNT_FILTER)) {
              return handleNewlyPresent(join(FLEX_USB_MOUNT_DIR, entry))
            }
            return null
          }),
        ])
      })
      .then(present => {
        log.info(`now present: ${present}`)
        prevDirs = present.filter((entry): entry is string => entry !== null)
      })

  const mediaWatcherCreator = (): fs.FSWatcher | null => {
    try {
      return fs.watch(
        FLEX_USB_MOUNT_DIR,
        { persistent: true },
        (event, fileName) => {
          if (!!!fileName) {
            rescan(dispatch)
            return
          }
          if (!fileName.match(FLEX_USB_MOUNT_FILTER)) {
            log.debug(
              `mediaWatcher: filename ${fileName} does not match ${FLEX_USB_MOUNT_FILTER}`
            )
            return
          }
          const fullPath = join(FLEX_USB_MOUNT_DIR, fileName)
          fsPromises
            .stat(fullPath)
            .then(info => {
              if (!info.isDirectory) {
                log.debug(`mediaWatcher: ${fullPath} is not a directory`)
                return
              }
              if (prevDirs.includes(fullPath)) {
                log.debug(`mediaWatcher: ${fullPath} is known`)
                return
              }
              log.info(`New mass storage device ${fileName} detected`)
              prevDirs.push(fullPath)
              return handleNewlyPresent(fullPath)
            })
            .catch(err => {
              if (prevDirs.includes(fullPath)) {
                log.info(
                  `Mass storage device at ${fileName} removed because its mount point disappeared`,
                  err
                )
                prevDirs = prevDirs.filter(entry => entry !== fullPath)
                dispatch(robotMassStorageDeviceRemoved(fullPath))
              } else {
                log.debug(
                  `Mass storage device candidate mountpoint at ${fileName} disappeared`,
                  err
                )
              }
            })
        }
      )
    } catch {
      log.error(`Failed to start watcher for ${FLEX_USB_MOUNT_DIR}`)
      return null
    }
  }

  const mediaWatcher = mediaWatcherCreator()

  const devWatcher = fs.watch(
    FLEX_USB_DEVICE_DIR,
    { persistent: true },
    (event, fileName) => {
      if (!!!fileName) return
      if (!fileName.match(FLEX_USB_DEVICE_FILTER)) return
      if (event !== 'rename') {
        log.debug(
          `devWatcher: ignoring ${event} event for ${fileName} (not rename)`
        )
        return
      }
      log.debug(`devWatcher: ${event} event for ${fileName}`)
      fsPromises
        .readdir(FLEX_USB_DEVICE_DIR)
        .then(contents => {
          if (contents.includes(fileName)) {
            log.debug(
              `devWatcher: ${fileName} found in /dev, this is an attach`
            )
            // this is an attach
            return
          }
          const prevDir = prevDirs.filter(dir => dir.includes(fileName)).at(0)
          log.debug(
            `devWatcher: ${fileName} not in /dev, this is a remove, previously mounted at ${prevDir}`
          )
          if (prevDir != null) {
            log.info(`Mass storage device at ${fileName} removed`)
            prevDirs = prevDirs.filter(entry => entry !== prevDir)
            dispatch(robotMassStorageDeviceRemoved(prevDir))
            // we don't care if this fails because it's racing the system removing
            // the mount dir in the common case
            fsPromises.unlink(prevDir).catch(() => {})
          }
        })
        .catch(err => {
          log.info(
            `Failed to handle mass storage device ${fileName}: ${err.name}: ${err.message}`
          )
        })
    }
  )

  rescan(dispatch)
  return () => {
    mediaWatcher != null && mediaWatcher.close()
    devWatcher.close()
  }
}

const getLatestMassStorageCsvFiles = (
  filePaths: string[],
  dispatch: Dispatch
): void => {
  // Note (kk:07/29/2024) get all files' last path
  // remove Resource fork that starts "._"
  // remove hidden file that starts "."
  const csvFilePaths = filePaths.filter(path => {
    const fileName = path.split('/').pop() || ''
    return (
      !fileName.startsWith('._') &&
      !fileName.startsWith('.') &&
      fileName.endsWith('.csv')
    )
  })
  dispatch(sendFilePaths(csvFilePaths))
}

export function registerDataFiles(
  dispatch: Dispatch
): (action: Action) => unknown {
  return function handleAction(action: Action) {
    switch (action.type) {
      case ROBOT_MASS_STORAGE_DEVICE_ENUMERATED: {
        getLatestMassStorageCsvFiles(action.payload.filePaths, dispatch)
        break
      }

      case ROBOT_MASS_STORAGE_DEVICE_REMOVED: {
        dispatch(sendFilePaths([]))
        break
      }

      default:
        break
    }
  }
}
